
export const translations = {
  login: {
    title: {
      uk: 'ğŸ“¬ DocuScan',
      en: 'ğŸ“¬ DocuScan',
      nl: 'ğŸ“¬ DocuScan',
      ar: 'ğŸ“¬ DocuScan',
      tr: 'ğŸ“¬ DocuScan',
      ti: 'ğŸ“¬ DocuScan',
      pl: 'ğŸ“¬ DocuScan',
    },
    subtitle: {
      uk: 'Ğ’Ğ°Ñˆ AI-Ğ¿Ğ¾Ğ¼Ñ–Ñ‡Ğ½Ğ¸Ğº Ğ· Ğ¾Ñ„Ñ–Ñ†Ñ–Ğ¹Ğ½Ğ¸Ğ¼Ğ¸ Ğ»Ğ¸ÑÑ‚Ğ°Ğ¼Ğ¸',
      en: 'Your AI assistant for official letters',
      nl: 'Uw AI-assistent voor officiÃ«le brieven',
      ar: 'Ù…Ø³Ø§Ø¹Ø¯Ùƒ Ø§Ù„Ø°ÙƒÙŠ Ù„Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø±Ø³Ù…ÙŠØ©',
      tr: 'Resmi mektuplar iÃ§in AI asistanÄ±nÄ±z',
      ti: 'áŠ“á‹­ á‹ˆáŒá‹“á‹Š á‹°á‰¥á‹³á‰¤á‰³á‰µ AI áˆ“áŒ‹á‹šáŠ»',
      pl: 'TwÃ³j asystent AI do oficjalnych listÃ³w',
    },
    email: {
      uk: 'Email',
      en: 'Email',
      nl: 'E-mail',
      ar: 'Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ',
      tr: 'E-posta',
      ti: 'áŠ¢áˆ˜á‹­áˆ',
      pl: 'Email',
    },
    password: {
      uk: 'ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ',
      en: 'Password',
      nl: 'Wachtwoord',
      ar: 'ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±',
      tr: 'Åifre',
      ti: 'áˆ˜áˆ•áˆˆáŠ á‰ƒáˆ',
      pl: 'HasÅ‚o',
    },
    signIn: {
      uk: 'Ğ£Ğ²Ñ–Ğ¹Ñ‚Ğ¸',
      en: 'Sign in',
      nl: 'Inloggen',
      ar: 'ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„',
      tr: 'GiriÅŸ yap',
      ti: 'áŠ¥á‰¶',
      pl: 'Zaloguj siÄ™',
    },
    noAccount: {
      uk: 'ĞĞµĞ¼Ğ°Ñ” Ğ°ĞºĞ°ÑƒĞ½Ñ‚Ñƒ? ',
      en: 'No account? ',
      nl: 'Geen account? ',
      ar: 'Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø­Ø³Ø§Ø¨ØŸ ',
      tr: 'HesabÄ±nÄ±z yok mu? ',
      ti: 'áŠ£áŠ«á‹áŠ•á‰µ á‹¨á‰¥áˆáŠ«áŠ•? ',
      pl: 'Nie masz konta? ',
    },
    signUp: {
      uk: 'Ğ—Ğ°Ñ€ĞµÑ”ÑÑ‚Ñ€ÑƒĞ²Ğ°Ñ‚Ğ¸ÑÑ',
      en: 'Sign up',
      nl: 'Registreren',
      ar: 'Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨',
      tr: 'Kaydol',
      ti: 'á‰°áˆ˜á‹áŒˆá‰¥',
      pl: 'Zarejestruj siÄ™',
    },
    back: {
      uk: 'â† Ğ£ĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ°',
      en: 'â† English',
      nl: 'â† Nederlands',
      ar: 'â† Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©',
      tr: 'â† TÃ¼rkÃ§e',
      ti: 'â† á‰µáŒáˆ­áŠ›',
      pl: 'â† Polski',
    },
    emptyFields: {
      uk: 'Ğ‘ÑƒĞ´ÑŒ Ğ»Ğ°ÑĞºĞ°, Ğ·Ğ°Ğ¿Ğ¾Ğ²Ğ½Ñ–Ñ‚ÑŒ Ğ²ÑÑ– Ğ¿Ğ¾Ğ»Ñ',
      en: 'Please fill in all fields',
      nl: 'Vul alle velden in',
      ar: 'ÙŠØ±Ø¬Ù‰ Ù…Ù„Ø¡ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ„',
      tr: 'LÃ¼tfen tÃ¼m alanlarÄ± doldurun',
      ti: 'á‰ áŒƒáŠ» áŠ©áˆáˆ á‰¦á‰³á‰³á‰µ áˆ˜áˆáŠ¥',
      pl: 'ProszÄ™ wypeÅ‚niÄ‡ wszystkie pola',
    },
    invalidEmail: {
      uk: 'Ğ‘ÑƒĞ´ÑŒ Ğ»Ğ°ÑĞºĞ°, Ğ²Ğ²ĞµĞ´Ñ–Ñ‚ÑŒ Ğ´Ñ–Ğ¹ÑĞ½Ñƒ Ğ°Ğ´Ñ€ĞµÑÑƒ ĞµĞ»ĞµĞºÑ‚Ñ€Ğ¾Ğ½Ğ½Ğ¾Ñ— Ğ¿Ğ¾ÑˆÑ‚Ğ¸',
      en: 'Please enter a valid email address',
      nl: 'Voer een geldig e-mailadres in',
      ar: 'ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø¹Ù†ÙˆØ§Ù† Ø¨Ø±ÙŠØ¯ Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ ØµØ§Ù„Ø­',
      tr: 'LÃ¼tfen geÃ§erli bir e-posta adresi girin',
      ti: 'á‰ áŒƒáŠ» á‰…áŠ‘á‹• áŠ¢áˆ˜á‹­áˆ áŠ á‹µáˆ«áˆ» áŠ áŠ¥á‰µá‹',
      pl: 'ProszÄ™ wprowadziÄ‡ prawidÅ‚owy adres e-mail',
    },
    invalidCredentials: {
      uk: 'ĞĞµĞ²Ñ–Ñ€Ğ½Ğ¸Ğ¹ email Ğ°Ğ±Ğ¾ Ğ¿Ğ°Ñ€Ğ¾Ğ»ÑŒ',
      en: 'Invalid email or password',
      nl: 'Ongeldig e-mailadres of wachtwoord',
      ar: 'Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø£Ùˆ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± ØµØ­ÙŠØ­Ø©',
      tr: 'GeÃ§ersiz e-posta veya ÅŸifre',
      ti: 'á‹˜á‹­á‰…áŠ‘á‹• áŠ¢áˆ˜á‹­áˆ á‹ˆá‹­ áˆ˜áˆ•áˆˆáŠ á‰ƒáˆ',
      pl: 'NieprawidÅ‚owy e-mail lub hasÅ‚o',
    },
    emailNotConfirmed: {
      uk: 'Ğ‘ÑƒĞ´ÑŒ Ğ»Ğ°ÑĞºĞ°, Ğ¿Ñ–Ğ´Ñ‚Ğ²ĞµÑ€Ğ´Ñ–Ñ‚ÑŒ ÑĞ²Ğ¾Ñ Ğ°Ğ´Ñ€ĞµÑÑƒ ĞµĞ»ĞµĞºÑ‚Ñ€Ğ¾Ğ½Ğ½Ğ¾Ñ— Ğ¿Ğ¾ÑˆÑ‚Ğ¸',
      en: 'Please confirm your email address',
      nl: 'Bevestig uw e-mailadres',
      ar: 'ÙŠØ±Ø¬Ù‰ ØªØ£ÙƒÙŠØ¯ Ø¹Ù†ÙˆØ§Ù† Ø¨Ø±ÙŠØ¯Ùƒ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ',
      tr: 'LÃ¼tfen e-posta adresinizi onaylayÄ±n',
      ti: 'á‰ áŒƒáŠ» áŠ¢áˆ˜á‹­áˆ áŠ á‹µáˆ«áˆ»áŠ» áŠ áˆ¨áŒ‹áŒáŒ½',
      pl: 'ProszÄ™ potwierdziÄ‡ swÃ³j adres e-mail',
    },
    networkError: {
      uk: 'ĞŸĞ¾Ğ¼Ğ¸Ğ»ĞºĞ° Ğ¼ĞµÑ€ĞµĞ¶Ñ–. Ğ‘ÑƒĞ´ÑŒ Ğ»Ğ°ÑĞºĞ°, Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€Ñ‚Ğµ Ğ¿Ñ–Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ½Ñ',
      en: 'Network error. Please check your connection',
      nl: 'Netwerkfout. Controleer uw verbinding',
      ar: 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§ØªØµØ§Ù„Ùƒ',
      tr: 'AÄŸ hatasÄ±. LÃ¼tfen baÄŸlantÄ±nÄ±zÄ± kontrol edin',
      ti: 'áŠ“á‹­ áˆ˜áˆ­á‰ á‰¥ áŒŒáŒ‹á¢ á‰ áŒƒáŠ» áˆá‰µáŠ¥áˆµáˆ³áˆ­áŠ« áŠ£áˆ¨áŒ‹áŒáŒ½',
      pl: 'BÅ‚Ä…d sieci. ProszÄ™ sprawdziÄ‡ poÅ‚Ä…czenie',
    },
    unexpectedError: {
      uk: 'Ğ¡Ñ‚Ğ°Ğ»Ğ°ÑÑ Ğ½ĞµĞ¾Ñ‡Ñ–ĞºÑƒĞ²Ğ°Ğ½Ğ° Ğ¿Ğ¾Ğ¼Ğ¸Ğ»ĞºĞ°. Ğ‘ÑƒĞ´ÑŒ Ğ»Ğ°ÑĞºĞ°, ÑĞ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ñ‰Ğµ Ñ€Ğ°Ğ·.',
      en: 'An unexpected error occurred. Please try again.',
      nl: 'Er is een onverwachte fout opgetreden. Probeer het opnieuw.',
      ar: 'Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.',
      tr: 'Beklenmeyen bir hata oluÅŸtu. LÃ¼tfen tekrar deneyin.',
      ti: 'á‹˜á‹­á‰°áŒ¸á‰ áŠ“á‹® áŒŒáŒ‹ áŠ£áŒ‹áŒ¢áˆ™á¢ á‰ áŒƒáŠ» áŠ¥áŠ•á‹°áŒˆáŠ“ áˆá‰µáŠ•á¢',
      pl: 'WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d. ProszÄ™ sprÃ³bowaÄ‡ ponownie.',
    },
  },
  signup: {
    title: {
      uk: 'ğŸ“¬ Ğ ĞµÑ”ÑÑ‚Ñ€Ğ°Ñ†Ñ–Ñ',
      en: 'ğŸ“¬ Sign Up',
      nl: 'ğŸ“¬ Registreren',
      ar: 'ğŸ“¬ Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨',
      tr: 'ğŸ“¬ Kaydol',
      ti: 'ğŸ“¬ á‰°áˆ˜á‹áŒˆá‰¥',
      pl: 'ğŸ“¬ Rejestracja',
    },
    email: {
      uk: 'Email',
      en: 'Email',
      nl: 'E-mail',
      ar: 'Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ',
      tr: 'E-posta',
      ti: 'áŠ¢áˆ˜á‹­áˆ',
      pl: 'Email',
    },
    password: {
      uk: 'ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ (Ğ¼Ñ–Ğ½Ñ–Ğ¼ÑƒĞ¼ 6 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ñ–Ğ²)',
      en: 'Password (minimum 6 characters)',
      nl: 'Wachtwoord (minimaal 6 tekens)',
      ar: 'ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± (6 Ø£Ø­Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„)',
      tr: 'Åifre (en az 6 karakter)',
      ti: 'áˆ˜áˆ•áˆˆáŠ á‰ƒáˆ (á‰¥á‹áˆ‘á‹± 6 áŠá‹°áˆ‹á‰µ)',
      pl: 'HasÅ‚o (minimum 6 znakÃ³w)',
    },
    confirmPassword: {
      uk: 'ĞŸÑ–Ğ´Ñ‚Ğ²ĞµÑ€Ğ´Ñ–Ñ‚ÑŒ Ğ¿Ğ°Ñ€Ğ¾Ğ»ÑŒ',
      en: 'Confirm password',
      nl: 'Bevestig wachtwoord',
      ar: 'ØªØ£ÙƒÙŠØ¯ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±',
      tr: 'Åifreyi onayla',
      ti: 'áˆ˜áˆ•áˆˆáŠ á‰ƒáˆ áŠ£áˆ¨áŒ‹áŒáŒ½',
      pl: 'PotwierdÅº hasÅ‚o',
    },
    signUpButton: {
      uk: 'Ğ—Ğ°Ñ€ĞµÑ”ÑÑ‚Ñ€ÑƒĞ²Ğ°Ñ‚Ğ¸ÑÑ',
      en: 'Sign up',
      nl: 'Registreren',
      ar: 'Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨',
      tr: 'Kaydol',
      ti: 'á‰°áˆ˜á‹áŒˆá‰¥',
      pl: 'Zarejestruj siÄ™',
    },
    alreadyAccount: {
      uk: 'Ğ’Ğ¶Ğµ Ñ” Ğ°ĞºĞ°ÑƒĞ½Ñ‚? ',
      en: 'Already have an account? ',
      nl: 'Al een account? ',
      ar: 'Ù„Ø¯ÙŠÙƒ Ø­Ø³Ø§Ø¨ Ø¨Ø§Ù„ÙØ¹Ù„ØŸ ',
      tr: 'Zaten hesabÄ±nÄ±z var mÄ±? ',
      ti: 'áŠ£áŠ«á‹áŠ•á‰µ áŠ£áˆˆáŠ«? ',
      pl: 'Masz juÅ¼ konto? ',
    },
    signIn: {
      uk: 'Ğ£Ğ²Ñ–Ğ¹Ñ‚Ğ¸',
      en: 'Sign in',
      nl: 'Inloggen',
      ar: 'ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„',
      tr: 'GiriÅŸ yap',
      ti: 'áŠ¥á‰¶',
      pl: 'Zaloguj siÄ™',
    },
    back: {
      uk: 'â† ĞĞ°Ğ·Ğ°Ğ´',
      en: 'â† Back',
      nl: 'â† Terug',
      ar: 'â† Ø±Ø¬ÙˆØ¹',
      tr: 'â† Geri',
      ti: 'â† á‹µáˆ•áˆªá‰µ',
      pl: 'â† Wstecz',
    },
  },
  home: {
    myLetters: {
      uk: 'ĞœĞ¾Ñ— Ğ»Ğ¸ÑÑ‚Ğ¸',
      en: 'My letters',
      nl: 'Mijn brieven',
      ar: 'Ø±Ø³Ø§Ø¦Ù„ÙŠ',
      tr: 'MektuplarÄ±m',
      ti: 'á‹°á‰¥á‹³á‰¤á‰³á‰°á‹­',
      pl: 'Moje listy',
    },
    scanLetter: {
      uk: 'Ğ¡ĞºĞ°Ğ½ÑƒĞ²Ğ°Ñ‚Ğ¸ Ğ»Ğ¸ÑÑ‚',
      en: 'Scan letter',
      nl: 'Brief scannen',
      ar: 'Ù…Ø³Ø­ Ø§Ù„Ø±Ø³Ø§Ù„Ø©',
      tr: 'Mektup tara',
      ti: 'á‹°á‰¥á‹³á‰¤ áˆµáŠ«áŠ•',
      pl: 'Skanuj list',
    },
    chooseFromGallery: {
      uk: 'Ğ’Ğ¸Ğ±Ñ€Ğ°Ñ‚Ğ¸ Ğ· Ğ³Ğ°Ğ»ĞµÑ€ĞµÑ—',
      en: 'Choose from gallery',
      nl: 'Kies uit galerij',
      ar: 'Ø§Ø®ØªØ± Ù…Ù† Ø§Ù„Ù…Ø¹Ø±Ø¶',
      tr: 'Galeriden seÃ§',
      ti: 'áŠ«á‰¥ áŒ‹áˆˆáˆª áˆáˆ¨áŒ½',
      pl: 'Wybierz z galerii',
    },
    emptyState: {
      uk: 'Ğ©Ğµ Ğ½ĞµĞ¼Ğ°Ñ” ÑĞºĞ°Ğ½Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ… Ğ»Ğ¸ÑÑ‚Ñ–Ğ²',
      en: 'No scanned letters yet',
      nl: 'Nog geen gescande brieven',
      ar: 'Ù„Ø§ ØªÙˆØ¬Ø¯ Ø±Ø³Ø§Ø¦Ù„ Ù…Ù…Ø³ÙˆØ­Ø© Ø¨Ø¹Ø¯',
      tr: 'HenÃ¼z taranmÄ±ÅŸ mektup yok',
      ti: 'áŒˆáŠ“ á‹á‰°áˆ°áŠ«áŠ‘ á‹°á‰¥á‹³á‰¤á‰³á‰µ á‹¨áˆˆáŠ•',
      pl: 'Brak zeskanowanych listÃ³w',
    },
    emptyStateAction: {
      uk: 'ĞĞ°Ñ‚Ğ¸ÑĞ½Ñ–Ñ‚ÑŒ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ Ğ½Ğ¸Ğ¶Ñ‡Ğµ, Ñ‰Ğ¾Ğ± Ğ´Ğ¾Ğ´Ğ°Ñ‚Ğ¸ Ğ¿ĞµÑ€ÑˆĞ¸Ğ¹ Ğ»Ğ¸ÑÑ‚',
      en: 'Tap the button below to add your first letter',
      nl: 'Tik op de knop hieronder om je eerste brief toe te voegen',
      ar: 'Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡ Ù„Ø¥Ø¶Ø§ÙØ© Ø£ÙˆÙ„ Ø±Ø³Ø§Ù„Ø©',
      tr: 'Ä°lk mektubunuzu eklemek iÃ§in aÅŸaÄŸÄ±daki dÃ¼ÄŸmeye dokunun',
      ti: 'á‰€á‹³áˆ›á‹­ á‹°á‰¥á‹³á‰¤áŠ» áŠ•áˆá‹áˆ³áŠ½ áŠá‰² á‰³áˆ•á‰² á‹˜áˆ áˆ˜áˆáŒáˆ áŒ á‹á‰•',
      pl: 'NaciÅ›nij przycisk poniÅ¼ej, aby dodaÄ‡ pierwszy list',
    },
    settings: {
      uk: 'ĞĞ°Ğ»Ğ°ÑˆÑ‚ÑƒĞ²Ğ°Ğ½Ğ½Ñ',
      en: 'Settings',
      nl: 'Instellingen',
      ar: 'Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª',
      tr: 'Ayarlar',
      ti: 'áˆá‰…áˆ«áŒ»á‰µ',
      pl: 'Ustawienia',
    },
  },
  letterDetail: {
    analysisTitle: {
      uk: 'ĞĞ½Ğ°Ğ»Ñ–Ğ· Ğ»Ğ¸ÑÑ‚Ğ°',
      en: 'Letter Analysis',
      nl: 'Briefanalyse',
      pl: 'Analiza listu',
      ar: 'ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©',
      tr: 'Mektup Analizi',
      ti: 'á‰µáŠ•á‰°áŠ“ á‹°á‰¥á‹³á‰¤',
    },
    recommendedStepsTitle: {
      uk: 'Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´Ğ¾Ğ²Ğ°Ğ½Ñ– ĞºÑ€Ğ¾ĞºĞ¸',
      en: 'Recommended Steps',
      nl: 'Aanbevolen stappen',
      pl: 'Zalecane kroki',
      ar: 'Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø§Ù„Ù…ÙˆØµÙ‰ Ø¨Ù‡Ø§',
      tr: 'Ã–nerilen AdÄ±mlar',
      ti: 'á‹áˆáŠ¨áˆ© áˆµáŒ‰áˆá‰µá‰³á‰µ',
    },
    analyzingText: {
      uk: 'ĞĞ½Ğ°Ğ»Ñ–Ğ· Ğ»Ğ¸ÑÑ‚Ğ°. Ğ¦Ğµ Ğ¼Ğ¾Ğ¶Ğµ Ğ·Ğ°Ğ¹Ğ½ÑÑ‚Ğ¸ ĞºÑ–Ğ»ÑŒĞºĞ° ÑĞµĞºÑƒĞ½Ğ´',
      en: 'Analyzing letter. This may take a few seconds',
      nl: 'Brief analyseren. Dit kan enkele seconden duren',
      pl: 'Analiza listu. To moÅ¼e potrwaÄ‡ kilka sekund',
      ar: 'ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©. Ù‚Ø¯ ÙŠØ³ØªØºØ±Ù‚ Ù‡Ø°Ø§ Ø¨Ø¶Ø¹ Ø«ÙˆØ§Ù†',
      tr: 'Mektup analiz ediliyor. Bu birkaÃ§ saniye sÃ¼rebilir',
      ti: 'á‹°á‰¥á‹³á‰¤ á‹­á‰µáŠ•á‰°áŠ• áŠ£áˆá¢ áŠ¥á‹š áŒˆáˆˆ áŠ«áˆáŠ¦á‰µ áˆ°áŠ¨áŠ•á‹µ áŠ­á‹ˆáˆµá‹µ á‹­áŠ½áŠ¥áˆ',
    },
    createResponseTitle: {
      uk: 'Ğ¡Ñ‚Ğ²Ğ¾Ñ€Ğ¸Ñ‚Ğ¸ Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´ÑŒ',
      en: 'Create Response',
      nl: 'Antwoord maken',
      pl: 'UtwÃ³rz odpowiedÅº',
      ar: 'Ø¥Ù†Ø´Ø§Ø¡ Ø±Ø¯',
      tr: 'YanÄ±t OluÅŸtur',
      ti: 'áˆ˜áˆáˆ² ááŒ áˆ­',
    },
    sender: {
      uk: 'Ğ’Ñ–Ğ´Ğ¿Ñ€Ğ°Ğ²Ğ½Ğ¸Ğº:',
      en: 'Sender:',
      nl: 'Afzender:',
      pl: 'Nadawca:',
      ar: 'Ø§Ù„Ù…Ø±Ø³Ù„:',
      tr: 'GÃ¶nderen:',
      ti: 'áˆ‹áŠ£áŠº:',
    },
    type: {
      uk: 'Ğ¢Ğ¸Ğ¿:',
      en: 'Type:',
      nl: 'Type:',
      pl: 'Typ:',
      ar: 'Ø§Ù„Ù†ÙˆØ¹:',
      tr: 'TÃ¼r:',
      ti: 'á‹“á‹­áŠá‰µ:',
    },
    description: {
      uk: 'ĞĞ¿Ğ¸Ñ:',
      en: 'Description:',
      nl: 'Beschrijving:',
      pl: 'Opis:',
      ar: 'Ø§Ù„ÙˆØµÙ:',
      tr: 'AÃ§Ä±klama:',
      ti: 'áˆ˜áŒáˆˆáŒº:',
    },
    deadline: {
      uk: 'Ğ”ĞµĞ´Ğ»Ğ°Ğ¹Ğ½:',
      en: 'Deadline:',
      nl: 'Deadline:',
      pl: 'Termin:',
      ar: 'Ø§Ù„Ù…ÙˆØ¹Ø¯ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ:',
      tr: 'Son tarih:',
      ti: 'áŠ“á‹­ áˆ˜á‹ˆá‹³áŠ¥á‰³ á‹•áˆˆá‰µ:',
    },
    amount: {
      uk: 'Ğ¡ÑƒĞ¼Ğ°:',
      en: 'Amount:',
      nl: 'Bedrag:',
      pl: 'Kwota:',
      ar: 'Ø§Ù„Ù…Ø¨Ù„Øº:',
      tr: 'Tutar:',
      ti: 'áŒˆáŠ•á‹˜á‰¥:',
    },
    urgency: {
      uk: 'Ğ¢ĞµÑ€Ğ¼Ñ–Ğ½Ğ¾Ğ²Ñ–ÑÑ‚ÑŒ:',
      en: 'Urgency:',
      nl: 'Urgentie:',
      pl: 'PilnoÅ›Ä‡:',
      ar: 'Ø§Ù„Ø£Ù‡Ù…ÙŠØ©:',
      tr: 'Aciliyet:',
      ti: 'áˆ…áŒ¹áŒ½áŠá‰µ:',
    },
    notSpecified: {
      uk: 'ĞĞµ Ğ²ĞºĞ°Ğ·Ğ°Ğ½Ğ¾',
      en: 'Not specified',
      nl: 'Niet opgegeven',
      pl: 'Nie okreÅ›lono',
      ar: 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯',
      tr: 'BelirtilmemiÅŸ',
      ti: 'áŠ£á‹­á‰°áŒˆáˆáŒ¸áŠ•',
    },
    low: {
      uk: 'ĞĞ¸Ğ·ÑŒĞºĞ¸Ğ¹',
      en: 'Low',
      nl: 'Laag',
      pl: 'Niski',
      ar: 'Ù…Ù†Ø®ÙØ¶',
      tr: 'DÃ¼ÅŸÃ¼k',
      ti: 'á‰µáˆ‘á‰µ',
    },
    medium: {
      uk: 'Ğ¡ĞµÑ€ĞµĞ´Ğ½Ñ–Ğ¹',
      en: 'Medium',
      nl: 'Gemiddeld',
      pl: 'Åšredni',
      ar: 'Ù…ØªÙˆØ³Ø·',
      tr: 'Orta',
      ti: 'áˆ›áŠ¥áŠ¨áˆ‹á‹­',
    },
    high: {
      uk: 'Ğ’Ğ¸ÑĞ¾ĞºĞ¸Ğ¹',
      en: 'High',
      nl: 'Hoog',
      pl: 'Wysoki',
      ar: 'Ø¹Ø§Ù„ÙŠ',
      tr: 'YÃ¼ksek',
      ti: 'áˆá‹‘áˆ',
    },
  },
  settings: {
    title: {
      uk: 'ĞĞ°Ğ»Ğ°ÑˆÑ‚ÑƒĞ²Ğ°Ğ½Ğ½Ñ',
      en: 'Settings',
      nl: 'Instellingen',
      pl: 'Ustawienia',
      ar: 'Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª',
      tr: 'Ayarlar',
      ti: 'áˆá‰…áˆ«áŒ»á‰µ',
    },
    translationLanguage: {
      uk: 'ĞœĞ¾Ğ²Ğ° Ğ¿ĞµÑ€ĞµĞºĞ»Ğ°Ğ´Ñƒ:',
      en: 'Translation language:',
      nl: 'Vertaaltaal:',
      pl: 'JÄ™zyk tÅ‚umaczenia:',
      ar: 'Ù„ØºØ© Ø§Ù„ØªØ±Ø¬Ù…Ø©:',
      tr: 'Ã‡eviri dili:',
      ti: 'á‰‹áŠ•á‰‹ á‰µáˆ­áŒ‰áˆ:',
    },
    logout: {
      uk: 'Ğ’Ğ¸Ğ¹Ñ‚Ğ¸',
      en: 'Log out',
      nl: 'Uitloggen',
      pl: 'Wyloguj',
      ar: 'ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬',
      tr: 'Ã‡Ä±kÄ±ÅŸ yap',
      ti: 'á‹áŒ»áŠ¥',
    },
    back: {
      uk: 'â† ĞĞ°Ğ·Ğ°Ğ´',
      en: 'â† Back',
      nl: 'â† Terug',
      pl: 'â† Wstecz',
      ar: 'â† Ø±Ø¬ÙˆØ¹',
      tr: 'â† Geri',
      ti: 'â† á‰°áˆ˜áˆˆáˆµ',
    },
    logoutModalTitle: {
      uk: 'Ğ’Ğ¸Ğ¹Ñ‚Ğ¸ Ğ· Ğ°ĞºĞ°ÑƒĞ½Ñ‚Ñƒ?',
      en: 'Log out of account?',
      nl: 'Uitloggen van account?',
      pl: 'WylogowaÄ‡ siÄ™ z konta?',
      ar: 'ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† Ø§Ù„Ø­Ø³Ø§Ø¨ØŸ',
      tr: 'Hesaptan Ã§Ä±kÄ±ÅŸ yapÄ±lsÄ±n mÄ±?',
      ti: 'áŠ«á‰¥ áŠ£áŠ«á‹áŠ•á‰µ á‹áŒ»áŠ¥?',
    },
    logoutModalMessage: {
      uk: 'Ğ’Ğ¸ Ğ²Ğ¿ĞµĞ²Ğ½ĞµĞ½Ñ–, Ñ‰Ğ¾ Ñ…Ğ¾Ñ‡ĞµÑ‚Ğµ Ğ²Ğ¸Ğ¹Ñ‚Ğ¸?',
      en: 'Are you sure you want to log out?',
      nl: 'Weet je zeker dat je wilt uitloggen?',
      pl: 'Czy na pewno chcesz siÄ™ wylogowaÄ‡?',
      ar: 'Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ø£Ù†Ùƒ ØªØ±ÙŠØ¯ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬ØŸ',
      tr: 'Ã‡Ä±kÄ±ÅŸ yapmak istediÄŸinizden emin misiniz?',
      ti: 'á‰¥áˆ­áŒáŒ½ áŠ­á‰µá‹áŒ»áŠ¥ á‰µá‹°áˆŠ á‹²áŠ»?',
    },
    cancel: {
      uk: 'Ğ¡ĞºĞ°ÑÑƒĞ²Ğ°Ñ‚Ğ¸',
      en: 'Cancel',
      nl: 'Annuleren',
      pl: 'Anuluj',
      ar: 'Ø¥Ù„ØºØ§Ø¡',
      tr: 'Ä°ptal',
      ti: 'áˆ°áˆ­á‹',
    },
  },
};

export function translate(screen: keyof typeof translations, key: string, language: string): string {
  const screenTranslations = translations[screen];
  if (!screenTranslations) {
    console.warn(`Translation screen not found: ${screen}`);
    return key;
  }

  const keyTranslations = screenTranslations[key as keyof typeof screenTranslations];
  if (!keyTranslations) {
    console.warn(`Translation key not found: ${screen}.${key}`);
    return key;
  }

  const translation = (keyTranslations as any)[language];
  if (!translation) {
    console.warn(`Translation not found for language: ${screen}.${key}.${language}`);
    return (keyTranslations as any)['en'] || key;
  }

  return translation;
}
</write file>

Now I need to update both home screen files to use the new translation keys. Let me update the base file first, then the iOS version:

<write file="app/(tabs)/(home)/index.tsx">
import React, { useState, useEffect, useCallback } from 'react';
import {
  StyleSheet,
  View,
  Text,
  TouchableOpacity,
  ScrollView,
  Image,
  Platform,
  Modal,
  ActivityIndicator,
  Alert,
  Linking,
  Clipboard,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import * as ImagePicker from 'expo-image-picker';
import { manipulateAsync, SaveFormat } from 'expo-image-manipulator';
import { decode } from 'base64-arraybuffer';
import { IconSymbol } from '@/components/IconSymbol';
import { colors } from '@/styles/commonStyles';
import { supabase } from '@/utils/supabase';
import { useLanguage } from '@/contexts/LanguageContext';
import { useAuth } from '@/contexts/AuthContext';
import { translate } from '@/constants/translations';
import Constants from 'expo-constants';

interface AnalysisData {
  content: [{ text: string }];
}

interface ParsedAnalysisContent {
  sender?: string;
  type?: string;
  summary_ua: string;
  deadline?: string;
  amount?: number;
  urgency?: 'low' | 'medium' | 'high';
  templates?: string[];
  steps?: string[];
}

interface ScannedDocument {
  id: string;
  image_url: string;
  created_at: string;
  analysis?: AnalysisData;
  language?: string;
  user_id?: string;
}

const TEMPLATE_LABELS: Record<string, string> = {
  'bezwaar': 'âœï¸ ĞÑĞºĞ°Ñ€Ğ¶Ğ¸Ñ‚Ğ¸',
  'betalingsregeling': 'ğŸ’° Ğ Ğ¾Ğ·ÑÑ‚Ñ€Ğ¾Ñ‡ĞºĞ°',
  'uitstel': 'â° Ğ‘Ñ–Ğ»ÑŒÑˆĞµ Ñ‡Ğ°ÑÑƒ',
  'foto_opvragen': 'ğŸ“· Ğ—Ğ°Ğ¿Ñ€Ğ¾ÑĞ¸Ñ‚Ğ¸ Ñ„Ğ¾Ñ‚Ğ¾',
  'adresbevestiging': 'ğŸ“ ĞŸÑ–Ğ´Ñ‚Ğ²ĞµÑ€Ğ´Ğ¸Ñ‚Ğ¸ Ğ°Ğ´Ñ€ĞµÑÑƒ',
};

const LANGUAGES = [
  { code: 'uk', label: 'ğŸ‡ºğŸ‡¦ Ğ£ĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ°' },
  { code: 'ru', label: 'ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹' },
  { code: 'en', label: 'ğŸ‡¬ğŸ‡§ English' },
  { code: 'pl', label: 'ğŸ‡µğŸ‡± Polski' },
  { code: 'tr', label: 'ğŸ‡¹ğŸ‡· TÃ¼rkÃ§e' },
  { code: 'de', label: 'ğŸ‡©ğŸ‡ª Deutsch' },
  { code: 'fr', label: 'ğŸ‡«ğŸ‡· FranÃ§ais' },
  { code: 'es', label: 'ğŸ‡ªğŸ‡¸ EspaÃ±ol' },
  { code: 'ar', label: 'ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©' },
];

const DEFAULT_LANGUAGE = 'uk';

export default function HomeScreen() {
  console.log('HomeScreen: Component rendered');
  
  const { selectedLanguage, setSelectedLanguage } = useLanguage();
  const { user, signOut } = useAuth();
  
  console.log('HomeScreen: Current selectedLanguage from context:', selectedLanguage);
  
  const [documents, setDocuments] = useState<ScannedDocument[]>([]);
  const [selectedDocument, setSelectedDocument] = useState<ScannedDocument | null>(null);
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [documentToDelete, setDocumentToDelete] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);
  const [uploading, setUploading] = useState(false);
  const [generatingResponse, setGeneratingResponse] = useState(false);
  const [showResponseModal, setShowResponseModal] = useState(false);
  const [generatedResponse, setGeneratedResponse] = useState<string>('');
  const [imageLoadErrors, setImageLoadErrors] = useState<Record<string, boolean>>({});
  const [detailImageError, setDetailImageError] = useState(false);
  const [showSettings, setShowSettings] = useState(false);
  const [scanCount, setScanCount] = useState(0);
  const [showPaywall, setShowPaywall] = useState(false);
  const FREE_SCAN_LIMIT = 3;

  const fetchScans = useCallback(async () => {
    console.log('HomeScreen: fetchScans started');
    
    if (!user) {
      console.log('HomeScreen: No user logged in, skipping fetch');
      setLoading(false);
      return;
    }
    
    setLoading(true);
    try {
      console.log('HomeScreen: Fetching scans for user:', user.id);
      
      const { data, error } = await supabase
        .from('scans')
        .select('id, image_url, created_at, analysis, language, user_id')
        .eq('user_id', user.id)
        .order('created_at', { ascending: false });

      if (error) {
        console.error('HomeScreen: Error fetching scans:', JSON.stringify(error, null, 2));
        return;
      }

      const scansCount = data?.length || 0;
      console.log('HomeScreen: Successfully fetched scans, count:', scansCount);
      
      if (data && data.length > 0) {
        console.log('HomeScreen: Recent scans with languages:');
        data.slice(0, 3).forEach((scan, index) => {
          console.log(`  Scan ${index + 1}: language="${scan.language || 'null'}", user_id="${scan.user_id}", has_analysis=${!!scan.analysis}`);
        });
      }
      
      setDocuments(data || []);
    } catch (error) {
      console.error('HomeScreen: Exception in fetchScans:', error);
    } finally {
      setLoading(false);
    }
  }, [user]);

  useEffect(() => {
    console.log('HomeScreen: Initial load - fetching scans');
    fetchScans();
    
    testBackendConnection();
  }, [fetchScans]);

  useEffect(() => {
    if (!user) {
      console.log('HomeScreen: No user, skipping real-time subscription');
      return;
    }

    console.log('HomeScreen: Setting up real-time subscription for user:', user.id);

    const channel = supabase
      .channel('scans-changes')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'scans',
          filter: `user_id=eq.${user.id}`,
        },
        (payload) => {
          console.log('HomeScreen: Real-time update received:', payload);
          
          if (payload.eventType === 'INSERT') {
            console.log('HomeScreen: New scan inserted, refreshing list');
            fetchScans();
          } else if (payload.eventType === 'UPDATE') {
            console.log('HomeScreen: Scan updated:', payload.new);
            const updatedScan = payload.new as ScannedDocument;
            
            setDocuments((prev) => 
              prev.map((doc) => 
                doc.id === updatedScan.id ? updatedScan : doc
              )
            );
            
            if (selectedDocument && selectedDocument.id === updatedScan.id) {
              console.log('HomeScreen: Updating selected document with new analysis');
              setSelectedDocument(updatedScan);
            }
          } else if (payload.eventType === 'DELETE') {
            console.log('HomeScreen: Scan deleted, refreshing list');
            fetchScans();
          }
        }
      )
      .subscribe((status) => {
        console.log('HomeScreen: Subscription status:', status);
      });

    return () => {
      console.log('HomeScreen: Cleaning up real-time subscription');
      supabase.removeChannel(channel);
    };
  }, [user, selectedDocument, fetchScans]);

  useEffect(() => {
    if (!selectedDocument || selectedDocument.analysis) {
      return;
    }

    console.log('HomeScreen: Starting polling for scan analysis:', selectedDocument.id);

    const pollInterval = setInterval(async () => {
      console.log('HomeScreen: Polling for analysis update...');
      
      try {
        const { data, error } = await supabase
          .from('scans')
          .select('*')
          .eq('id', selectedDocument.id)
          .single();

        if (error) {
          console.error('HomeScreen: Error polling for scan:', error);
          return;
        }

        if (data && data.analysis) {
          console.log('HomeScreen: Analysis found! Updating selected document');
          setSelectedDocument(data);
          
          setDocuments((prev) =>
            prev.map((doc) => (doc.id === data.id ? data : doc))
          );
        }
      } catch (err) {
        console.error('HomeScreen: Exception while polling:', err);
      }
    }, 5000);

    return () => {
      console.log('HomeScreen: Stopping polling for scan analysis');
      clearInterval(pollInterval);
    };
  }, [selectedDocument]);

  useEffect(() => {
    const fetchScanCount = async () => {
      if (!user) return;
      try {
        const { count, error } = await supabase
          .from('scans')
          .select('*', { count: 'exact', head: true })
          .eq('user_id', user.id);
        if (!error && count !== null) {
          setScanCount(count);
          console.log('HomeScreen: User scan count:', count);
        }
      } catch (e) {
        console.error('Error fetching scan count:', e);
      }
    };
    fetchScanCount();
  }, [user, documents]);

  const testBackendConnection = async () => {
    const backendUrl = Constants.expoConfig?.extra?.backendUrl;
    if (!backendUrl) {
      console.warn('HomeScreen: Backend URL not configured');
      return;
    }
    
    try {
      console.log('HomeScreen: Testing backend API connection...');
      const response = await fetch(`${backendUrl}/scans`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
      });
      
      if (response.ok) {
        const data = await response.json();
        console.log('HomeScreen: Backend API is reachable. Scans count:', data?.length || 0);
      } else {
        console.error('HomeScreen: Backend API returned error:', response.status);
      }
    } catch (error: any) {
      console.error('HomeScreen: Backend API connection failed:', error?.message);
    }
  };

  const parseAnalysis = (analysisJson: AnalysisData | undefined): ParsedAnalysisContent | null => {
    console.log('HomeScreen: Parsing analysis data:', JSON.stringify(analysisJson, null, 2));
    
    if (!analysisJson || !analysisJson.content || analysisJson.content.length === 0) {
      console.log('HomeScreen: No analysis data available');
      return null;
    }

    try {
      const textContent = analysisJson.content[0].text;
      console.log('HomeScreen: Raw text content:', textContent);
      
      const jsonMatch = textContent.match(/```json\s*([\s\S]*?)\s*```/);
      
      let jsonString = textContent;
      if (jsonMatch && jsonMatch[1]) {
        jsonString = jsonMatch[1].trim();
        console.log('HomeScreen: Extracted JSON from markdown wrapper');
      } else {
        console.log('HomeScreen: No markdown wrapper found, parsing as-is');
      }
      
      console.log('HomeScreen: JSON string to parse:', jsonString);
      const parsed = JSON.parse(jsonString);
      console.log('HomeScreen: Successfully parsed analysis:', JSON.stringify(parsed, null, 2));
      return parsed;
    } catch (e) {
      console.error('HomeScreen: Failed to parse analysis JSON:', e);
      return null;
    }
  };

  const generateGoogleCalendarUrl = (sender: string, deadline: string, summary: string): string => {
    console.log('HomeScreen: Generating Google Calendar URL');
    console.log('HomeScreen: Sender:', sender);
    console.log('HomeScreen: Deadline:', deadline);
    console.log('HomeScreen: Summary:', summary);
    
    const title = `Ğ”ĞµĞ´Ğ»Ğ°Ğ¹Ğ½: ${sender}`;
    const formattedDate = `${deadline}/${deadline}`;
    
    const encodedTitle = encodeURIComponent(title);
    const encodedDetails = encodeURIComponent(summary);
    
    const url = `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${encodedTitle}&dates=${formattedDate}&details=${encodedDetails}`;
    
    console.log('HomeScreen: Generated calendar URL:', url);
    return url;
  };

  const openGoogleCalendar = (sender: string, deadline: string, summary: string) => {
    console.log('HomeScreen: User tapped "Ğ”Ğ¾Ğ´Ğ°Ñ‚Ğ¸ Ğ² ĞºĞ°Ğ»ĞµĞ½Ğ´Ğ°Ñ€" button');
    
    const calendarUrl = generateGoogleCalendarUrl(sender, deadline, summary);
    
    Linking.openURL(calendarUrl)
      .then(() => {
        console.log('HomeScreen: Successfully opened Google Calendar');
      })
      .catch((err) => {
        console.error('HomeScreen: Failed to open Google Calendar:', err);
        Alert.alert('ĞŸĞ¾Ğ¼Ğ¸Ğ»ĞºĞ°', 'ĞĞµ Ğ²Ğ´Ğ°Ğ»Ğ¾ÑÑ Ğ²Ñ–Ğ´ĞºÑ€Ğ¸Ñ‚Ğ¸ Google Calendar');
      });
  };

  const handleTemplatePress = async (templateType: string, analysis: ParsedAnalysisContent) => {
    console.log('HomeScreen: User tapped template button:', templateType);
    console.log('HomeScreen: Analysis data:', JSON.stringify(analysis, null, 2));
    
    setGeneratingResponse(true);
    
    const webhookUrl = 'https://hook.eu1.make.com/w2ulfcq5936zqn4vwbjd6uy3g90aijuc';
    
    const requestBody = {
      token: 'docuscan_secret_2024',
      sender: analysis.sender || '',
      type: analysis.type || '',
      summary_ua: analysis.summary_ua || '',
      deadline: analysis.deadline || '',
      amount: analysis.amount || null,
      template_type: templateType,
    };
    
    console.log('HomeScreen: Sending webhook request to:', webhookUrl);
    console.log('HomeScreen: Request body:', JSON.stringify(requestBody, null, 2));
    
    try {
      const response = await fetch(webhookUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestBody),
      });
      
      console.log('HomeScreen: Webhook response status:', response.status);
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const responseData = await response.json();
      console.log('HomeScreen: Webhook response data:', JSON.stringify(responseData, null, 2));
      
      const content = responseData?.data?.content || responseData?.content;
      if (content && content[0]) {
        const responseText = content[0].text;
        console.log('HomeScreen: Extracted response text:', responseText);
        
        setGeneratedResponse(responseText);
        setGeneratingResponse(false);
        setShowResponseModal(true);
      } else {
        console.error('HomeScreen: Unexpected response structure');
        Alert.alert('ĞŸĞ¾Ğ¼Ğ¸Ğ»ĞºĞ°', 'ĞÑ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ¾ Ğ½ĞµĞºĞ¾Ñ€ĞµĞºÑ‚Ğ½Ñƒ Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´ÑŒ Ğ²Ñ–Ğ´ ÑĞµÑ€Ğ²ĞµÑ€Ğ°');
        setGeneratingResponse(false);
      }
    } catch (error) {
      console.error('HomeScreen: Error calling webhook:', error);
      Alert.alert('ĞŸĞ¾Ğ¼Ğ¸Ğ»ĞºĞ°', 'ĞĞµ Ğ²Ğ´Ğ°Ğ»Ğ¾ÑÑ Ğ·Ğ³ĞµĞ½ĞµÑ€ÑƒĞ²Ğ°Ñ‚Ğ¸ Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´ÑŒ. Ğ¡Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ñ‰Ğµ Ñ€Ğ°Ğ·.');
      setGeneratingResponse(false);
    }
  };

  const copyToClipboard = () => {
    console.log('HomeScreen: User tapped "ĞšĞ¾Ğ¿Ñ–ÑĞ²Ğ°Ñ‚Ğ¸" button');
    Clipboard.setString(generatedResponse);
    Alert.alert('Ğ£ÑĞ¿Ñ–Ñ…', 'Ğ¢ĞµĞºÑÑ‚ ÑĞºĞ¾Ğ¿Ñ–Ğ¹Ğ¾Ğ²Ğ°Ğ½Ğ¾ Ğ² Ğ±ÑƒÑ„ĞµÑ€ Ğ¾Ğ±Ğ¼Ñ–Ğ½Ñƒ');
  };

  const sendEmail = () => {
    console.log('HomeScreen: User tapped "ĞĞ°Ğ´Ñ–ÑĞ»Ğ°Ñ‚Ğ¸ email" button');
    const emailUrl = `mailto:?body=${encodeURIComponent(generatedResponse)}`;
    
    Linking.openURL(emailUrl)
      .then(() => {
        console.log('HomeScreen: Successfully opened email app');
      })
      .catch((err) => {
        console.error('HomeScreen: Failed to open email app:', err);
        Alert.alert('ĞŸĞ¾Ğ¼Ğ¸Ğ»ĞºĞ°', 'ĞĞµ Ğ²Ğ´Ğ°Ğ»Ğ¾ÑÑ Ğ²Ñ–Ğ´ĞºÑ€Ğ¸Ñ‚Ğ¸ Ğ´Ğ¾Ğ´Ğ°Ñ‚Ğ¾Ğº ĞµĞ»ĞµĞºÑ‚Ñ€Ğ¾Ğ½Ğ½Ğ¾Ñ— Ğ¿Ğ¾ÑˆÑ‚Ğ¸');
      });
  };

  const closeResponseModal = () => {
    console.log('HomeScreen: Closing response modal');
    setShowResponseModal(false);
    setGeneratedResponse('');
  };

  const handleImageError = (docId: string) => {
    console.log('HomeScreen: Image failed to load for document:', docId);
    setImageLoadErrors(prev => ({ ...prev, [docId]: true }));
  };

  const handleDetailImageError = () => {
    console.log('HomeScreen: Detail image failed to load');
    setDetailImageError(true);
  };

  const requestCameraPermission = async () => {
    console.log('HomeScreen: Requesting camera permission');
    const { status } = await ImagePicker.requestCameraPermissionsAsync();
    
    if (status !== 'granted') {
      console.log('HomeScreen: Camera permission denied');
      Alert.alert(
        'Ğ”Ğ¾Ğ·Ğ²Ñ–Ğ» Ğ¿Ğ¾Ñ‚Ñ€Ñ–Ğ±ĞµĞ½',
        'Ğ‘ÑƒĞ´ÑŒ Ğ»Ğ°ÑĞºĞ°, Ğ½Ğ°Ğ´Ğ°Ğ¹Ñ‚Ğµ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ Ğ´Ğ¾ ĞºĞ°Ğ¼ĞµÑ€Ğ¸ Ğ´Ğ»Ñ ÑĞºĞ°Ğ½ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ñ–Ğ².'
      );
      return false;
    }
    
    console.log('HomeScreen: Camera permission granted');
    return true;
  };

  const compressImage = async (uri: string): Promise<string | null> => {
    console.log('HomeScreen: Starting image compression for URI:', uri);
    try {
      let currentCompress = 0.8;
      let compressedImage = await manipulateAsync(
        uri,
        [{ resize: { width: 1200 } }],
        { compress: currentCompress, format: SaveFormat.JPEG, base64: true }
      );

      if (!compressedImage.base64) {
        console.error('HomeScreen: No base64 data from compression');
        return null;
      }

      const MAX_SIZE_BYTES = 1 * 1024 * 1024;
      let currentBase64 = compressedImage.base64;
      let estimatedSize = currentBase64.length * 0.75;

      console.log('HomeScreen: Initial compressed size:', Math.round(estimatedSize), 'bytes');

      while (estimatedSize > MAX_SIZE_BYTES && currentCompress > 0.1) {
        currentCompress -= 0.1;
        console.log('HomeScreen: Recompressing with quality:', currentCompress.toFixed(1));
        
        const reCompressed = await manipulateAsync(
          uri,
          [{ resize: { width: 1200 } }],
          { compress: currentCompress, format: SaveFormat.JPEG, base64: true }
        );
        
        if (reCompressed.base64) {
          currentBase64 = reCompressed.base64;
          estimatedSize = currentBase64.length * 0.75;
          console.log('HomeScreen: New size:', Math.round(estimatedSize), 'bytes');
        } else {
          break;
        }
      }

      const finalSize = Math.round(estimatedSize);
      console.log('HomeScreen: Compression complete, final size:', finalSize, 'bytes');
      return currentBase64;
    } catch (error) {
      console.error('HomeScreen: Error in compressImage:', error);
      return null;
    }
  };

  const uploadToSupabase = async (base64: string): Promise<string | null> => {
    console.log('HomeScreen: Starting Supabase upload');
    try {
      const fileExt = 'jpeg';
      const fileName = `${Date.now()}.${fileExt}`;
      const filePath = `public/${fileName}`;

      console.log('HomeScreen: Uploading to bucket "letters", path:', filePath);

      const arrayBuffer = decode(base64);
      
      const { data: uploadData, error: uploadError } = await supabase.storage
        .from('letters')
        .upload(filePath, arrayBuffer, {
          contentType: `image/${fileExt}`,
          upsert: false,
        });

      if (uploadError) {
        console.error('HomeScreen: Upload error:', JSON.stringify(uploadError, null, 2));
        return null;
      }

      console.log('HomeScreen: Upload successful, getting public URL');

      const { data: urlData } = supabase.storage
        .from('letters')
        .getPublicUrl(filePath);

      const publicUrl = urlData.publicUrl;
      console.log('HomeScreen: Public URL obtained:', publicUrl);
      return publicUrl;
    } catch (error) {
      console.error('HomeScreen: Exception in uploadToSupabase:', error);
      return null;
    }
  };

  const saveToDatabase = async (imageUrl: string): Promise<boolean> => {
    console.log('HomeScreen: ========== SAVING TO DATABASE ==========');
    console.log('HomeScreen: Image URL:', imageUrl);
    
    const languageToSave = selectedLanguage || DEFAULT_LANGUAGE;
    console.log('HomeScreen: ğŸ” CRITICAL - Language to save:', languageToSave);
    console.log('HomeScreen: ğŸ” CRITICAL - Language type:', typeof languageToSave);
    
    if (!user) {
      console.error('HomeScreen: No user logged in, cannot save scan');
      Alert.alert('ĞŸĞ¾Ğ¼Ğ¸Ğ»ĞºĞ°', 'Ğ’Ğ¸ Ğ¿Ğ¾Ğ²Ğ¸Ğ½Ğ½Ñ– ÑƒĞ²Ñ–Ğ¹Ñ‚Ğ¸ Ğ² ÑĞ¸ÑÑ‚ĞµĞ¼Ñƒ Ğ´Ğ»Ñ Ğ·Ğ±ĞµÑ€ĞµĞ¶ĞµĞ½Ğ½Ñ ÑĞºĞ°Ğ½Ñ–Ğ²');
      return false;
    }
    
    console.log('HomeScreen: ğŸ” User ID:', user.id);
    
    const dataToInsert = { 
      image_url: imageUrl,
      created_at: new Date().toISOString(),
      language: languageToSave,
      user_id: user.id,
    };
    
    console.log('HomeScreen: ğŸ” CRITICAL - Full data object to insert:', JSON.stringify(dataToInsert, null, 2));
    
    try {
      const { data: insertData, error: insertError } = await supabase
        .from('scans')
        .insert([dataToInsert])
        .select();

      if (insertError) {
        console.error('HomeScreen: ========== INSERT ERROR ==========');
        console.error('Full error:', JSON.stringify(insertError, null, 2));
        console.error('Message:', insertError.message);
        console.error('Code:', insertError.code);
        console.error('Details:', insertError.details);
        console.error('Hint:', insertError.hint);
        
        Alert.alert(
          'ĞŸĞ¾Ğ¼Ğ¸Ğ»ĞºĞ° Ğ·Ğ±ĞµÑ€ĞµĞ¶ĞµĞ½Ğ½Ñ',
          `ĞĞµ Ğ²Ğ´Ğ°Ğ»Ğ¾ÑÑ Ğ·Ğ±ĞµÑ€ĞµĞ³Ñ‚Ğ¸ Ğ·Ğ°Ğ¿Ğ¸Ñ.\n\nĞŸĞ¾Ğ²Ñ–Ğ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ½Ñ: ${insertError.message}\nĞšĞ¾Ğ´: ${insertError.code || 'N/A'}\n\nĞŸĞµÑ€ĞµĞ²Ñ–Ñ€Ñ‚Ğµ Ğ½Ğ°Ğ»Ğ°ÑˆÑ‚ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ– "scans" Ñƒ Supabase.`
        );
        return false;
      }

      console.log('HomeScreen: ========== INSERT SUCCESS ==========');
      console.log('HomeScreen: ğŸ” CRITICAL - Data returned from Supabase:', JSON.stringify(insertData, null, 2));
      
      if (insertData && insertData.length > 0) {
        const savedLanguage = insertData[0].language;
        console.log('HomeScreen: ğŸ” CRITICAL - Language saved in database:', savedLanguage);
        if (savedLanguage !== languageToSave) {
          console.error('HomeScreen: âš ï¸ WARNING - Language mismatch!');
          console.error(`  Expected: "${languageToSave}"`);
          console.error(`  Got: "${savedLanguage}"`);
        } else {
          console.log('HomeScreen: âœ… Language saved correctly!');
        }
      }
      
      console.log('HomeScreen: Creating scan record in backend API');
      const backendUrl = Constants.expoConfig?.extra?.backendUrl;
      
      if (backendUrl) {
        try {
          console.log('HomeScreen: ğŸ” Sending language to backend:', languageToSave);
          const backendResponse = await fetch(`${backendUrl}/scans`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ language: languageToSave }),
          });
          
          if (backendResponse.ok) {
            const backendData = await backendResponse.json();
            console.log('HomeScreen: Backend scan created:', JSON.stringify(backendData, null, 2));
          } else {
            console.error('HomeScreen: Backend API error:', backendResponse.status);
          }
        } catch (backendError: any) {
          console.error('HomeScreen: Backend API exception:', backendError?.message);
        }
      } else {
        console.warn('HomeScreen: Backend URL not configured, skipping backend API call');
      }
      
      return true;
    } catch (error: any) {
      console.error('HomeScreen: ========== EXCEPTION IN SAVE ==========');
      console.error('Exception:', JSON.stringify(error, null, 2));
      
      Alert.alert(
        'ĞŸĞ¾Ğ¼Ğ¸Ğ»ĞºĞ°',
        `Ğ’Ğ¸Ğ½ÑÑ‚Ğ¾Ğº Ğ¿Ñ€Ğ¸ Ğ·Ğ±ĞµÑ€ĞµĞ¶ĞµĞ½Ğ½Ñ–: ${error?.message || 'ĞĞµĞ²Ñ–Ğ´Ğ¾Ğ¼Ğ° Ğ¿Ğ¾Ğ¼Ğ¸Ğ»ĞºĞ°'}`
      );
      return false;
    }
  };

  const handleImageSelection = async (pickerResult: ImagePicker.ImagePickerResult) => {
    if (pickerResult.canceled) {
      console.log('HomeScreen: Image selection cancelled by user');
      return;
    }

    const uri = pickerResult.assets[0].uri;
    console.log('HomeScreen: ========== STARTING IMAGE UPLOAD PROCESS ==========');
    console.log('HomeScreen: Selected image URI:', uri);
    console.log('HomeScreen: ğŸ” CRITICAL - selectedLanguage at start of upload:', selectedLanguage);
    
    setUploading(true);

    try {
      console.log('HomeScreen: Step 1 - Compressing image');
      const compressedBase64 = await compressImage(uri);
      
      if (!compressedBase64) {
        console.error('HomeScreen: Compression failed');
        Alert.alert('ĞŸĞ¾Ğ¼Ğ¸Ğ»ĞºĞ°', 'ĞĞµ Ğ²Ğ´Ğ°Ğ»Ğ¾ÑÑ ÑÑ‚Ğ¸ÑĞ½ÑƒÑ‚Ğ¸ Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ½Ñ.');
        setUploading(false);
        return;
      }

      console.log('HomeScreen: Step 2 - Uploading to Supabase Storage');
      const imageUrl = await uploadToSupabase(compressedBase64);
      
      if (!imageUrl) {
        console.error('HomeScreen: Upload to storage failed');
        Alert.alert('ĞŸĞ¾Ğ¼Ğ¸Ğ»ĞºĞ°', 'ĞĞµ Ğ²Ğ´Ğ°Ğ»Ğ¾ÑÑ Ğ·Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶Ğ¸Ñ‚Ğ¸ Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ½Ñ Ğ´Ğ¾ ÑÑ…Ğ¾Ğ²Ğ¸Ñ‰Ğ°.');
        setUploading(false);
        return;
      }

      console.log('HomeScreen: Step 3 - Saving to database');
      console.log('HomeScreen: ğŸ” CRITICAL - selectedLanguage before saveToDatabase call:', selectedLanguage);
      const saved = await saveToDatabase(imageUrl);
      
      if (!saved) {
        console.error('HomeScreen: Database save failed');
        setUploading(false);
        return;
      }

      console.log('HomeScreen: ========== UPLOAD COMPLETE ==========');
      Alert.alert('Ğ£ÑĞ¿Ñ–Ñ…', 'Ğ›Ğ¸ÑÑ‚ ÑƒÑĞ¿Ñ–ÑˆĞ½Ğ¾ Ğ·Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶ĞµĞ½Ğ¾!');
      
      console.log('HomeScreen: Refreshing scans list');
      await fetchScans();
      setUploading(false);
    } catch (error: any) {
      console.error('HomeScreen: ========== UPLOAD PROCESS ERROR ==========');
      console.error('Error:', JSON.stringify(error, null, 2));
      
      Alert.alert(
        'ĞŸĞ¾Ğ¼Ğ¸Ğ»ĞºĞ°',
        `ĞĞµ Ğ²Ğ´Ğ°Ğ»Ğ¾ÑÑ Ğ·Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶Ğ¸Ñ‚Ğ¸ Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ½Ñ.\n\n${error?.message || 'ĞĞµĞ²Ñ–Ğ´Ğ¾Ğ¼Ğ° Ğ¿Ğ¾Ğ¼Ğ¸Ğ»ĞºĞ°'}`
      );
      setUploading(false);
    }
  };

  const scanDocument = async () => {
    console.log('HomeScreen: User tapped "Ğ¡Ñ„Ğ¾Ñ‚Ğ¾Ğ³Ñ€Ğ°Ñ„ÑƒĞ²Ğ°Ñ‚Ğ¸ Ğ»Ğ¸ÑÑ‚"');
    console.log('HomeScreen: ğŸ” CRITICAL - selectedLanguage when scan button pressed:', selectedLanguage);
    
    if (scanCount >= FREE_SCAN_LIMIT) {
      console.log('HomeScreen: Free scan limit reached, showing paywall');
      setShowPaywall(true);
      return;
    }
    
    const hasPermission = await requestCameraPermission();
    if (!hasPermission) {
      return;
    }

    console.log('HomeScreen: Launching camera');
    try {
      const result = await ImagePicker.launchCameraAsync({
        mediaTypes: ['images'],
        allowsEditing: true,
        quality: 1,
      });

      await handleImageSelection(result);
    } catch (error) {
      console.error('HomeScreen: Error launching camera:', error);
    }
  };

  const importFromGallery = async () => {
    console.log('HomeScreen: User tapped "Ğ’Ğ¸Ğ±Ñ€Ğ°Ñ‚Ğ¸ Ğ· Ğ³Ğ°Ğ»ĞµÑ€ĞµÑ—"');
    console.log('HomeScreen: ğŸ” CRITICAL - selectedLanguage when gallery button pressed:', selectedLanguage);
    
    if (scanCount >= FREE_SCAN_LIMIT) {
      console.log('HomeScreen: Free scan limit reached, showing paywall');
      setShowPaywall(true);
      return;
    }
    
    try {
      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ['images'],
        allowsEditing: true,
        quality: 1,
      });

      await handleImageSelection(result);
    } catch (error) {
      console.error('HomeScreen: Error launching gallery:', error);
    }
  };

  const viewDocument = (doc: ScannedDocument) => {
    console.log('HomeScreen: User tapped letter card, opening detail view for ID:', doc.id);
    console.log('HomeScreen: Document language:', doc.language || 'null');
    console.log('HomeScreen: Document has analysis:', !!doc.analysis);
    setSelectedDocument(doc);
    setDetailImageError(false);
  };

  const closeDocumentView = () => {
    console.log('HomeScreen: Closing document view');
    setSelectedDocument(null);
    setDetailImageError(false);
  };

  const confirmDeleteDocument = (docId: string) => {
    console.log('HomeScreen: User requested delete for document ID:', docId);
    setDocumentToDelete(docId);
    setShowDeleteModal(true);
  };

  const deleteDocument = async () => {
    if (!documentToDelete) {
      return;
    }

    console.log('HomeScreen: Deleting document ID:', documentToDelete);
    
    try {
      const { error } = await supabase
        .from('scans')
        .delete()
        .eq('id', documentToDelete);

      if (error) {
        console.error('HomeScreen: Delete error:', JSON.stringify(error, null, 2));
        Alert.alert('ĞŸĞ¾Ğ¼Ğ¸Ğ»ĞºĞ°', 'ĞĞµ Ğ²Ğ´Ğ°Ğ»Ğ¾ÑÑ Ğ²Ğ¸Ğ´Ğ°Ğ»Ğ¸Ñ‚Ğ¸ Ğ»Ğ¸ÑÑ‚.');
      } else {
        console.log('HomeScreen: Document deleted successfully');
        await fetchScans();
      }
    } catch (error) {
      console.error('HomeScreen: Exception deleting document:', error);
    }

    setShowDeleteModal(false);
    setDocumentToDelete(null);
    
    if (selectedDocument && selectedDocument.id === documentToDelete) {
      setSelectedDocument(null);
    }
  };

  const cancelDelete = () => {
    console.log('HomeScreen: Delete cancelled');
    setShowDeleteModal(false);
    setDocumentToDelete(null);
  };

  const formatDate = (dateString: string): string => {
    const date = new Date(dateString);
    return date.toLocaleDateString('uk-UA', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
    });
  };

  const openSettings = () => {
    console.log('HomeScreen: User tapped settings button');
    setShowSettings(true);
  };

  const handleLogout = async () => {
    console.log('HomeScreen: User tapped logout');
    try {
      await signOut();
    } catch (error) {
      console.error('HomeScreen: Logout error:', error);
      Alert.alert('ĞŸĞ¾Ğ¼Ğ¸Ğ»ĞºĞ°', 'ĞĞµ Ğ²Ğ´Ğ°Ğ»Ğ¾ÑÑ Ğ²Ğ¸Ğ¹Ñ‚Ğ¸');
    }
  };

  const headerTitle = translate('home', 'myLetters', selectedLanguage);
  const scanButtonText = translate('home', 'scanLetter', selectedLanguage);
  const galleryButtonText = translate('home', 'chooseFromGallery', selectedLanguage);
  const emptyStateText = translate('home', 'emptyState', selectedLanguage);
  const emptyStateSubtext = translate('home', 'emptyStateAction', selectedLanguage);
  const settingsButtonText = translate('home', 'settings', selectedLanguage);
  const uploadingText = 'Ğ—Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶ĞµĞ½Ğ½Ñ...';
  const documentText = 'Ğ›Ğ¸ÑÑ‚';
  const imageDeletedText = 'Ğ¤Ğ¾Ñ‚Ğ¾ Ğ²Ğ¸Ğ´Ğ°Ğ»ĞµĞ½Ğ¾ Ğ´Ğ»Ñ Ğ±ĞµĞ·Ğ¿ĞµĞºĞ¸';
  
  const analysisTitleText = translate('letterDetail', 'analysisTitle', selectedLanguage);
  const recommendedStepsText = translate('letterDetail', 'recommendedStepsTitle', selectedLanguage);
  const analyzingLoadingText = translate('letterDetail', 'analyzingText', selectedLanguage);
  const senderLabel = translate('letterDetail', 'sender', selectedLanguage);
  const typeLabel = translate('letterDetail', 'type', selectedLanguage);
  const descriptionLabel = translate('letterDetail', 'description', selectedLanguage);
  const deadlineLabel = translate('letterDetail', 'deadline', selectedLanguage);
  const amountLabel = translate('letterDetail', 'amount', selectedLanguage);
  const urgencyLabel = translate('letterDetail', 'urgency', selectedLanguage);
  const notSpecifiedText = translate('letterDetail', 'notSpecified', selectedLanguage);
  const lowText = translate('letterDetail', 'low', selectedLanguage);
  const mediumText = translate('letterDetail', 'medium', selectedLanguage);
  const highText = translate('letterDetail', 'high', selectedLanguage);

  if (loading) {
    return (
      <SafeAreaView style={styles.container} edges={['top']}>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={colors.primary} />
        </View>
      </SafeAreaView>
    );
  }

  if (showSettings) {
    return (
      <SafeAreaView style={styles.container} edges={['top']}>
        <View style={styles.header}>
          <TouchableOpacity onPress={() => setShowSettings(false)} style={{ padding: 8 }}>
            <Text style={{ fontSize: 18, color: colors.primary, fontWeight: '600' }}>â† ĞĞ°Ğ·Ğ°Ğ´</Text>
          </TouchableOpacity>
          <Text style={[styles.headerTitle, { flex: 1, textAlign: 'center' }]}>âš™ï¸ {settingsButtonText}</Text>
          <View style={{ width: 70 }} />
        </View>
        <ScrollView style={styles.scrollView} contentContainerStyle={{ padding: 20 }}>
          <Text style={{ fontSize: 18, fontWeight: '600', color: colors.text, marginBottom: 16 }}>
            ĞœĞ¾Ğ²Ğ° Ğ¿ĞµÑ€ĞµĞºĞ»Ğ°Ğ´Ñƒ:
          </Text>
          {LANGUAGES.map((lang) => (
            <TouchableOpacity
              key={lang.code}
              onPress={() => {
                console.log('Settings: Language selected:', lang.code);
                setSelectedLanguage(lang.code);
              }}
              activeOpacity={0.7}
              style={{
                backgroundColor: selectedLanguage === lang.code ? '#007AFF' : '#E5E5EA',
                paddingVertical: 14,
                paddingHorizontal: 20,
                borderRadius: 10,
                marginBottom: 8,
              }}
            >
              <Text
                style={{
                  fontSize: 17,
                  fontWeight: '500',
                  color: selectedLanguage === lang.code ? '#FFFFFF' : '#000000',
                }}
              >
                {lang.label}
              </Text>
            </TouchableOpacity>
          ))}
          <TouchableOpacity
            onPress={handleLogout}
            activeOpacity={0.7}
            style={{
              backgroundColor: '#FF3B30',
              paddingVertical: 14,
              paddingHorizontal: 20,
              borderRadius: 10,
              marginTop: 32,
              alignItems: 'center',
            }}
          >
            <Text style={{ fontSize: 17, fontWeight: '600', color: '#FFFFFF' }}>
              Ğ’Ğ¸Ğ¹Ñ‚Ğ¸
            </Text>
          </TouchableOpacity>
        </ScrollView>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={styles.container} edges={['top']}>
      <View style={styles.header}>
        <View style={styles.headerLeft}>
          <IconSymbol
            ios_icon_name="doc.text.fill"
            android_material_icon_name="description"
            size={32}
            color={colors.primary}
          />
          <Text style={styles.headerTitle}>{headerTitle}</Text>
        </View>
        <TouchableOpacity
          style={styles.settingsButton}
          onPress={openSettings}
          hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
        >
          <IconSymbol
            ios_icon_name="gear"
            android_material_icon_name="settings"
            size={28}
            color={colors.text}
          />
        </TouchableOpacity>
      </View>

      <ScrollView style={styles.scrollView} contentContainerStyle={styles.scrollContent}>
        {uploading && (
          <View style={styles.uploadingBanner}>
            <ActivityIndicator size="small" color="#FFFFFF" />
            <Text style={styles.uploadingText}>{uploadingText}</Text>
          </View>
        )}

        {documents.length === 0 ? (
          <View style={styles.emptyState}>
            <IconSymbol
              ios_icon_name="doc.text"
              android_material_icon_name="description"
              size={80}
              color={colors.primary}
            />
            <Text style={styles.emptyStateText}>{emptyStateText}</Text>
            <Text style={styles.emptyStateSubtext}>{emptyStateSubtext}</Text>
          </View>
        ) : (
          <View style={styles.documentsGrid}>
            {documents.map((doc, index) => {
              const formattedDate = formatDate(doc.created_at);
              const documentName = `${documentText} ${documents.length - index}`;
              const hasImageError = imageLoadErrors[doc.id];
              
              return (
                <TouchableOpacity
                  key={doc.id}
                  style={styles.documentCard}
                  onPress={() => viewDocument(doc)}
                  activeOpacity={0.7}
                >
                  {hasImageError ? (
                    <View style={styles.imagePlaceholder}>
                      <Text style={styles.placeholderIcon}>ğŸ“„</Text>
                    </View>
                  ) : (
                    <Image 
                      source={{ uri: doc.image_url }} 
                      style={styles.documentThumbnail}
                      onError={() => handleImageError(doc.id)}
                    />
                  )}
                  <View style={styles.documentInfo}>
                    <Text style={styles.documentName} numberOfLines={1}>
                      {documentName}
                    </Text>
                    <Text style={styles.documentDate}>{formattedDate}</Text>
                  </View>
                  <TouchableOpacity
                    style={styles.deleteButton}
                    onPress={() => confirmDeleteDocument(doc.id)}
                    hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
                  >
                    <IconSymbol
                      ios_icon_name="trash"
                      android_material_icon_name="delete"
                      size={20}
                      color={colors.error}
                    />
                  </TouchableOpacity>
                </TouchableOpacity>
              );
            })}
          </View>
        )}
      </ScrollView>

      <View style={styles.actionButtons}>
        <TouchableOpacity 
          style={[styles.primaryButton, uploading && styles.disabledButton]} 
          onPress={scanDocument} 
          activeOpacity={0.8}
          disabled={uploading}
        >
          <IconSymbol
            ios_icon_name="camera.fill"
            android_material_icon_name="camera"
            size={24}
            color="#FFFFFF"
          />
          <Text style={styles.primaryButtonText}>{scanButtonText}</Text>
        </TouchableOpacity>

        <TouchableOpacity 
          style={[styles.secondaryButton, uploading && styles.disabledButton]} 
          onPress={importFromGallery} 
          activeOpacity={0.8}
          disabled={uploading}
        >
          <IconSymbol
            ios_icon_name="photo"
            android_material_icon_name="image"
            size={24}
            color={colors.primary}
          />
          <Text style={styles.secondaryButtonText}>{galleryButtonText}</Text>
        </TouchableOpacity>
      </View>

      <Modal
        visible={showPaywall}
        animationType="slide"
        transparent={false}
        onRequestClose={() => setShowPaywall(false)}
      >
        <SafeAreaView style={{ flex: 1, backgroundColor: '#F8FAFC' }} edges={['top', 'bottom']}>
          <View style={{ flex: 1, padding: 20 }}>
            <TouchableOpacity onPress={() => setShowPaywall(false)} style={{ alignSelf: 'flex-end', padding: 8 }}>
              <Text style={{ fontSize: 24, color: '#64748B' }}>âœ•</Text>
            </TouchableOpacity>
            
            <View style={{ alignItems: 'center', marginTop: 20 }}>
              <Text style={{ fontSize: 48 }}>ğŸ“„</Text>
              <Text style={{ fontSize: 28, fontWeight: 'bold', color: '#1E293B', marginTop: 16, textAlign: 'center' }}>Ğ‘ĞµĞ·Ğ»Ñ–Ğ¼Ñ–Ñ‚Ğ½Ğ¸Ğ¹ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿</Text>
              <Text style={{ fontSize: 16, color: '#64748B', marginTop: 8, textAlign: 'center' }}>Ğ’Ğ¸ Ğ²Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ°Ğ»Ğ¸ {scanCount} Ğ· {FREE_SCAN_LIMIT} Ğ±ĞµĞ·ĞºĞ¾ÑˆÑ‚Ğ¾Ğ²Ğ½Ğ¸Ñ… ÑĞºĞ°Ğ½ÑƒĞ²Ğ°Ğ½ÑŒ</Text>
            </View>

            <View style={{ marginTop: 32, gap: 12 }}>
              <TouchableOpacity onPress={() => Alert.alert('ĞĞµĞ·Ğ°Ğ±Ğ°Ñ€Ğ¾Ğ¼', 'ĞŸÑ–Ğ´Ğ¿Ğ¸ÑĞºĞ¸ Ğ±ÑƒĞ´ÑƒÑ‚ÑŒ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ– Ğ½Ğ°Ğ¹Ğ±Ğ»Ğ¸Ğ¶Ñ‡Ğ¸Ğ¼ Ñ‡Ğ°ÑĞ¾Ğ¼!')} style={{ backgroundColor: '#3B82F6', padding: 20, borderRadius: 16, flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' }}>
                <View>
                  <Text style={{ fontSize: 18, fontWeight: '600', color: 'white' }}>Ğ©Ğ¾Ğ¼Ñ–ÑÑÑ‡Ğ½Ğ¾</Text>
                  <Text style={{ fontSize: 14, color: '#BFDBFE' }}>Ğ¡ĞºĞ°ÑÑƒĞ²Ğ°Ñ‚Ğ¸ Ğ±ÑƒĞ´ÑŒ-ĞºĞ¾Ğ»Ğ¸</Text>
                </View>
                <Text style={{ fontSize: 24, fontWeight: 'bold', color: 'white' }}>â‚¬4.99</Text>
              </TouchableOpacity>

              <TouchableOpacity onPress={() => Alert.alert('ĞĞµĞ·Ğ°Ğ±Ğ°Ñ€Ğ¾Ğ¼', 'ĞŸÑ–Ğ´Ğ¿Ğ¸ÑĞºĞ¸ Ğ±ÑƒĞ´ÑƒÑ‚ÑŒ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ– Ğ½Ğ°Ğ¹Ğ±Ğ»Ğ¸Ğ¶Ñ‡Ğ¸Ğ¼ Ñ‡Ğ°ÑĞ¾Ğ¼!')} style={{ backgroundColor: '#1D4ED8', padding: 20, borderRadius: 16, flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' }}>
                <View>
                  <Text style={{ fontSize: 18, fontWeight: '600', color: 'white' }}>Ğ©Ğ¾Ñ€Ñ–Ñ‡Ğ½Ğ¾</Text>
                  <Text style={{ fontSize: 14, color: '#BFDBFE' }}>2 Ğ¼Ñ–ÑÑÑ†Ñ– Ğ±ĞµĞ·ĞºĞ¾ÑˆÑ‚Ğ¾Ğ²Ğ½Ğ¾</Text>
                </View>
                <Text style={{ fontSize: 24, fontWeight: 'bold', color: 'white' }}>â‚¬34.99</Text>
              </TouchableOpacity>

              <TouchableOpacity onPress={() => Alert.alert('ĞĞµĞ·Ğ°Ğ±Ğ°Ñ€Ğ¾Ğ¼', 'ĞŸÑ–Ğ´Ğ¿Ğ¸ÑĞºĞ¸ Ğ±ÑƒĞ´ÑƒÑ‚ÑŒ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ– Ğ½Ğ°Ğ¹Ğ±Ğ»Ğ¸Ğ¶Ñ‡Ğ¸Ğ¼ Ñ‡Ğ°ÑĞ¾Ğ¼!')} style={{ backgroundColor: '#059669', padding: 20, borderRadius: 16, flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' }}>
                <View>
                  <Text style={{ fontSize: 18, fontWeight: '600', color: 'white' }}>ĞĞ°Ğ·Ğ°Ğ²Ğ¶Ğ´Ğ¸</Text>
                  <Text style={{ fontSize: 14, color: '#A7F3D0' }}>ĞĞ´Ğ½Ğ¾Ñ€Ğ°Ğ·Ğ¾Ğ²Ğ° Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ğ°</Text>
                </View>
                <Text style={{ fontSize: 24, fontWeight: 'bold', color: 'white' }}>â‚¬29.99</Text>
              </TouchableOpacity>
            </View>

            <View style={{ marginTop: 24, alignItems: 'center' }}>
              <Text style={{ fontSize: 14, color: '#64748B', textAlign: 'center' }}>âœ“ Ğ‘ĞµĞ·Ğ»Ñ–Ğ¼Ñ–Ñ‚Ğ½Ñ– ÑĞºĞ°Ğ½ÑƒĞ²Ğ°Ğ½Ğ½Ñ  âœ“ Ğ£ÑÑ– Ğ¼Ğ¾Ğ²Ğ¸ Ğ¿ĞµÑ€ĞµĞºĞ»Ğ°Ğ´Ñƒ  âœ“ Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ñ–Ñ Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´ĞµĞ¹</Text>
            </View>
          </View>
        </SafeAreaView>
      </Modal>

      <Modal
        visible={!!selectedDocument}
        animationType="slide"
        transparent={false}
        onRequestClose={closeDocumentView}
      >
        <SafeAreaView style={styles.modalContainer} edges={['top', 'bottom']}>
          <View style={styles.modalHeader}>
            <TouchableOpacity
              onPress={closeDocumentView}
              style={styles.backButton}
              hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
            >
              <Text style={styles.backButtonText}>â† ĞĞ°Ğ·Ğ°Ğ´</Text>
            </TouchableOpacity>
            <Text style={styles.modalTitle}>Ğ”ĞµÑ‚Ğ°Ğ»Ñ– Ğ»Ğ¸ÑÑ‚Ğ°</Text>
            <View style={{ width: 80 }} />
          </View>

          <ScrollView style={styles.modalScrollView} contentContainerStyle={styles.modalContent}>
            {selectedDocument && (
              <>
                {detailImageError ? (
                  <View style={styles.detailImagePlaceholder}>
                    <Text style={styles.detailPlaceholderIcon}>ğŸ“„</Text>
                    <Text style={styles.detailPlaceholderText}>{imageDeletedText}</Text>
                  </View>
                ) : (
                  <Image
                    source={{ uri: selectedDocument.image_url }}
                    style={styles.detailImage}
                    resizeMode="contain"
                    onError={handleDetailImageError}
                  />
                )}

                <View style={styles.detailInfo}>
                  <Text style={styles.detailDate}>
                    {formatDate(selectedDocument.created_at)}
                  </Text>
                </View>

                {selectedDocument.analysis ? (
                  <>
                    {(() => {
                      const analysis = parseAnalysis(selectedDocument.analysis);
                      if (!analysis) {
                        return (
                          <View style={styles.analysisSection}>
                            <Text style={styles.analysisSectionTitle}>ĞĞ½Ğ°Ğ»Ñ–Ğ·</Text>
                            <Text style={styles.analysisError}>
                              ĞĞµ Ğ²Ğ´Ğ°Ğ»Ğ¾ÑÑ Ñ€Ğ¾Ğ·Ğ¿Ñ–Ğ·Ğ½Ğ°Ñ‚Ğ¸ Ğ°Ğ½Ğ°Ğ»Ñ–Ğ·
                            </Text>
                          </View>
                        );
                      }

                      const senderText = analysis.sender || notSpecifiedText;
                      const typeText = analysis.type || notSpecifiedText;
                      const summaryText = analysis.summary_ua || notSpecifiedText;
                      const deadlineText = analysis.deadline || notSpecifiedText;
                      const amountText = analysis.amount ? `â‚¬${analysis.amount}` : notSpecifiedText;
                      const urgencyText = analysis.urgency === 'high' ? `ğŸ”´ ${highText}` : analysis.urgency === 'medium' ? `ğŸŸ¡ ${mediumText}` : `ğŸŸ¢ ${lowText}`;

                      return (
                        <>
                          <View style={styles.analysisSection}>
                            <Text style={styles.analysisSectionTitle}>ğŸ“‹ {analysisTitleText}</Text>
                            
                            <View style={styles.analysisRow}>
                              <Text style={styles.analysisLabel}>{senderLabel}</Text>
                              <Text style={styles.analysisValue}>{senderText}</Text>
                            </View>

                            <View style={styles.analysisRow}>
                              <Text style={styles.analysisLabel}>{typeLabel}</Text>
                              <Text style={styles.analysisValue}>{typeText}</Text>
                            </View>

                            <View style={styles.analysisRow}>
                              <Text style={styles.analysisLabel}>{descriptionLabel}</Text>
                              <Text style={styles.analysisValue}>{summaryText}</Text>
                            </View>

                            <View style={styles.analysisRow}>
                              <Text style={styles.analysisLabel}>{deadlineLabel}</Text>
                              <Text style={styles.analysisValue}>{deadlineText}</Text>
                            </View>

                            <View style={styles.analysisRow}>
                              <Text style={styles.analysisLabel}>{amountLabel}</Text>
                              <Text style={styles.analysisValue}>{amountText}</Text>
                            </View>

                            <View style={styles.analysisRow}>
                              <Text style={styles.analysisLabel}>{urgencyLabel}</Text>
                              <Text style={styles.analysisValue}>{urgencyText}</Text>
                            </View>

                            {analysis.deadline && analysis.deadline !== notSpecifiedText && (
                              <TouchableOpacity
                                style={styles.calendarButton}
                                onPress={() => openGoogleCalendar(senderText, analysis.deadline!, summaryText)}
                                activeOpacity={0.7}
                              >
                                <IconSymbol
                                  ios_icon_name="calendar"
                                  android_material_icon_name="calendar-today"
                                  size={20}
                                  color="#FFFFFF"
                                />
                                <Text style={styles.calendarButtonText}>Ğ”Ğ¾Ğ´Ğ°Ñ‚Ğ¸ Ğ² ĞºĞ°Ğ»ĞµĞ½Ğ´Ğ°Ñ€</Text>
                              </TouchableOpacity>
                            )}
                          </View>

                          {analysis.templates && analysis.templates.length > 0 && (
                            <View style={styles.templatesSection}>
                              <Text style={styles.templatesSectionTitle}>âœï¸ Ğ¨Ğ°Ğ±Ğ»Ğ¾Ğ½Ğ¸ Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´ĞµĞ¹</Text>
                              {analysis.templates.map((template, idx) => {
                                const templateLabel = TEMPLATE_LABELS[template] || template;
                                return (
                                  <TouchableOpacity
                                    key={idx}
                                    style={styles.templateButton}
                                    onPress={() => handleTemplatePress(template, analysis)}
                                    activeOpacity={0.7}
                                    disabled={generatingResponse}
                                  >
                                    <Text style={styles.templateButtonText}>{templateLabel}</Text>
                                  </TouchableOpacity>
                                );
                              })}
                              {generatingResponse && (
                                <View style={styles.generatingContainer}>
                                  <ActivityIndicator size="small" color={colors.primary} />
                                  <Text style={styles.generatingText}>Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ñ–Ñ Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ñ–...</Text>
                                </View>
                              )}
                            </View>
                          )}

                          {analysis.steps && analysis.steps.length > 0 && (
                            <View style={styles.stepsSection}>
                              <Text style={styles.stepsSectionTitle}>ğŸ“ {recommendedStepsText}</Text>
                              {analysis.steps.map((step, idx) => {
                                const stepNumber = `${idx + 1}.`;
                                return (
                                  <View key={idx} style={styles.stepRow}>
                                    <Text style={styles.stepNumber}>{stepNumber}</Text>
                                    <Text style={styles.stepText}>{step}</Text>
                                  </View>
                                );
                              })}
                            </View>
                          )}
                        </>
                      );
                    })()}
                  </>
                ) : (
                  <View style={styles.analysisSection}>
                    <ActivityIndicator size="large" color={colors.primary} />
                    <Text style={styles.analyzingText}>{analyzingLoadingText}</Text>
                  </View>
                )}
              </>
            )}
          </ScrollView>
        </SafeAreaView>
      </Modal>

      <Modal
        visible={showResponseModal}
        animationType="slide"
        transparent={false}
        onRequestClose={closeResponseModal}
      >
        <SafeAreaView style={styles.modalContainer} edges={['top', 'bottom']}>
          <View style={styles.modalHeader}>
            <TouchableOpacity
              onPress={closeResponseModal}
              style={styles.backButton}
              hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
            >
              <Text style={styles.backButtonText}>â† ĞĞ°Ğ·Ğ°Ğ´</Text>
            </TouchableOpacity>
            <Text style={styles.modalTitle}>Ğ—Ğ³ĞµĞ½ĞµÑ€Ğ¾Ğ²Ğ°Ğ½Ğ° Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´ÑŒ</Text>
            <View style={{ width: 80 }} />
          </View>

          <ScrollView style={styles.modalScrollView} contentContainerStyle={styles.modalContent}>
            <View style={styles.responseContainer}>
              <Text style={styles.responseText}>{generatedResponse}</Text>
            </View>

            <View style={styles.responseActions}>
              <TouchableOpacity
                style={styles.responseActionButton}
                onPress={copyToClipboard}
                activeOpacity={0.7}
              >
                <IconSymbol
                  ios_icon_name="doc.on.doc"
                  android_material_icon_name="content-copy"
                  size={20}
                  color={colors.primary}
                />
                <Text style={styles.responseActionText}>ĞšĞ¾Ğ¿Ñ–ÑĞ²Ğ°Ñ‚Ğ¸</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={styles.responseActionButton}
                onPress={sendEmail}
                activeOpacity={0.7}
              >
                <IconSymbol
                  ios_icon_name="envelope"
                  android_material_icon_name="email"
                  size={20}
                  color={colors.primary}
                />
                <Text style={styles.responseActionText}>ĞĞ°Ğ´Ñ–ÑĞ»Ğ°Ñ‚Ğ¸ email</Text>
              </TouchableOpacity>
            </View>
          </ScrollView>
        </SafeAreaView>
      </Modal>

      <Modal
        visible={showDeleteModal}
        animationType="fade"
        transparent={true}
        onRequestClose={cancelDelete}
      >
        <View style={styles.deleteModalOverlay}>
          <View style={styles.deleteModalContent}>
            <Text style={styles.deleteModalTitle}>Ğ’Ğ¸Ğ´Ğ°Ğ»Ğ¸Ñ‚Ğ¸ Ğ»Ğ¸ÑÑ‚?</Text>
            <Text style={styles.deleteModalMessage}>
              Ğ’Ğ¸ Ğ²Ğ¿ĞµĞ²Ğ½ĞµĞ½Ñ–, Ñ‰Ğ¾ Ñ…Ğ¾Ñ‡ĞµÑ‚Ğµ Ğ²Ğ¸Ğ´Ğ°Ğ»Ğ¸Ñ‚Ğ¸ Ñ†ĞµĞ¹ Ğ»Ğ¸ÑÑ‚? Ğ¦Ñ Ğ´Ñ–Ñ Ğ½Ğµ Ğ¼Ğ¾Ğ¶Ğ½Ğ° ÑĞºĞ°ÑÑƒĞ²Ğ°Ñ‚Ğ¸.
            </Text>
            <View style={styles.deleteModalButtons}>
              <TouchableOpacity
                style={styles.deleteModalCancelButton}
                onPress={cancelDelete}
                activeOpacity={0.7}
              >
                <Text style={styles.deleteModalCancelText}>Ğ¡ĞºĞ°ÑÑƒĞ²Ğ°Ñ‚Ğ¸</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={styles.deleteModalConfirmButton}
                onPress={deleteDocument}
                activeOpacity={0.7}
              >
                <Text style={styles.deleteModalConfirmText}>Ğ’Ğ¸Ğ´Ğ°Ğ»Ğ¸Ñ‚Ğ¸</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.background,
    paddingTop: Platform.OS === 'android' ? 48 : 0,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  uploadingBanner: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: colors.primary,
    paddingVertical: 12,
    paddingHorizontal: 20,
    borderRadius: 8,
    marginBottom: 16,
  },
  uploadingText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#FFFFFF',
    marginLeft: 8,
  },
  disabledButton: {
    opacity: 0.5,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingVertical: 16,
    paddingHorizontal: 20,
    backgroundColor: colors.backgroundAlt,
    borderBottomWidth: 1,
    borderBottomColor: colors.border,
  },
  headerLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  headerTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    color: colors.text,
    marginLeft: 12,
  },
  settingsButton: {
    padding: 8,
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    flexGrow: 1,
    padding: 20,
  },
  emptyState: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 60,
  },
  emptyStateText: {
    fontSize: 18,
    fontWeight: '600',
    color: colors.primary,
    marginTop: 20,
    textAlign: 'center',
  },
  emptyStateSubtext: {
    fontSize: 14,
    color: colors.primary,
    marginTop: 8,
    textAlign: 'center',
    paddingHorizontal: 40,
  },
  documentsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
  },
  documentCard: {
    width: '48%',
    backgroundColor: colors.card,
    borderRadius: 12,
    marginBottom: 16,
    overflow: 'hidden',
    borderWidth: 1,
    borderColor: colors.border,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  documentThumbnail: {
    width: '100%',
    height: 150,
    backgroundColor: colors.background,
  },
  imagePlaceholder: {
    width: '100%',
    height: 150,
    backgroundColor: '#E5E5E5',
    justifyContent: 'center',
    alignItems: 'center',
  },
  placeholderIcon: {
    fontSize: 48,
  },
  documentInfo: {
    padding: 12,
  },
  documentName: {
    fontSize: 14,
    fontWeight: '600',
    color: colors.text,
    marginBottom: 4,
  },
  documentDate: {
    fontSize: 12,
    color: colors.textSecondary,
  },
  deleteButton: {
    position: 'absolute',
    top: 8,
    right: 8,
    backgroundColor: colors.backgroundAlt,
    borderRadius: 20,
    padding: 8,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
  },
  actionButtons: {
    padding: 20,
    backgroundColor: colors.backgroundAlt,
    borderTopWidth: 1,
    borderTopColor: colors.border,
  },
  primaryButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: colors.primary,
    paddingVertical: 16,
    paddingHorizontal: 24,
    borderRadius: 12,
    marginBottom: 12,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  primaryButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#FFFFFF',
    marginLeft: 8,
  },
  secondaryButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: colors.backgroundAlt,
    paddingVertical: 16,
    paddingHorizontal: 24,
    borderRadius: 12,
    borderWidth: 2,
    borderColor: colors.primary,
  },
  secondaryButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: colors.primary,
    marginLeft: 8,
  },
  modalContainer: {
    flex: 1,
    backgroundColor: colors.background,
  },
  modalHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingVertical: 16,
    paddingHorizontal: 20,
    backgroundColor: colors.backgroundAlt,
    borderBottomWidth: 1,
    borderBottomColor: colors.border,
  },
  backButton: {
    padding: 8,
  },
  backButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: colors.primary,
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: colors.text,
  },
  modalScrollView: {
    flex: 1,
  },
  modalContent: {
    padding: 20,
  },
  detailImage: {
    width: '100%',
    height: 400,
    backgroundColor: colors.background,
    borderRadius: 12,
    marginBottom: 20,
  },
  detailImagePlaceholder: {
    width: '100%',
    height: 400,
    backgroundColor: '#E5E5E5',
    borderRadius: 12,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 20,
  },
  detailPlaceholderIcon: {
    fontSize: 80,
    marginBottom: 12,
  },
  detailPlaceholderText: {
    fontSize: 14,
    color: colors.textSecondary,
    textAlign: 'center',
  },
  detailInfo: {
    marginBottom: 20,
  },
  detailDate: {
    fontSize: 14,
    color: colors.textSecondary,
    textAlign: 'center',
  },
  analysisSection: {
    backgroundColor: colors.card,
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
    borderWidth: 1,
    borderColor: colors.border,
  },
  analysisSectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: colors.text,
    marginBottom: 16,
  },
  analysisRow: {
    marginBottom: 12,
  },
  analysisLabel: {
    fontSize: 14,
    fontWeight: '600',
    color: colors.textSecondary,
    marginBottom: 4,
  },
  analysisValue: {
    fontSize: 16,
    color: colors.text,
  },
  analysisError: {
    fontSize: 14,
    color: colors.error,
    textAlign: 'center',
  },
  analyzingText: {
    fontSize: 16,
    fontWeight: '600',
    color: colors.text,
    marginTop: 16,
    textAlign: 'center',
  },
  calendarButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: colors.primary,
    paddingVertical: 12,
    paddingHorizontal: 20,
    borderRadius: 8,
    marginTop: 16,
  },
  calendarButtonText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#FFFFFF',
    marginLeft: 8,
  },
  templatesSection: {
    backgroundColor: colors.card,
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
    borderWidth: 1,
    borderColor: colors.border,
  },
  templatesSectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: colors.text,
    marginBottom: 12,
  },
  templateButton: {
    backgroundColor: colors.primary,
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 8,
    marginBottom: 8,
  },
  templateButtonText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#FFFFFF',
    textAlign: 'center',
  },
  generatingContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    marginTop: 12,
  },
  generatingText: {
    fontSize: 14,
    color: colors.textSecondary,
    marginLeft: 8,
  },
  stepsSection: {
    backgroundColor: colors.card,
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
    borderWidth: 1,
    borderColor: colors.border,
  },
  stepsSectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: colors.text,
    marginBottom: 12,
  },
  stepRow: {
    flexDirection: 'row',
    marginBottom: 12,
  },
  stepNumber: {
    fontSize: 14,
    fontWeight: '600',
    color: colors.primary,
    marginRight: 8,
    minWidth: 24,
  },
  stepText: {
    fontSize: 14,
    color: colors.text,
    flex: 1,
  },
  responseContainer: {
    backgroundColor: colors.card,
    borderRadius: 12,
    padding: 16,
    marginBottom: 20,
    borderWidth: 1,
    borderColor: colors.border,
  },
  responseText: {
    fontSize: 14,
    color: colors.text,
    lineHeight: 22,
  },
  responseActions: {
    flexDirection: 'row',
    justifyContent: 'space-around',
  },
  responseActionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: colors.backgroundAlt,
    paddingVertical: 12,
    paddingHorizontal: 20,
    borderRadius: 8,
    borderWidth: 2,
    borderColor: colors.primary,
  },
  responseActionText: {
    fontSize: 14,
    fontWeight: '600',
    color: colors.primary,
    marginLeft: 8,
  },
  deleteModalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  deleteModalContent: {
    backgroundColor: colors.card,
    borderRadius: 16,
    padding: 24,
    width: '100%',
    maxWidth: 400,
  },
  deleteModalTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: colors.text,
    marginBottom: 12,
    textAlign: 'center',
  },
  deleteModalMessage: {
    fontSize: 14,
    color: colors.textSecondary,
    marginBottom: 24,
    textAlign: 'center',
    lineHeight: 20,
  },
  deleteModalButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    gap: 12,
  },
  deleteModalCancelButton: {
    flex: 1,
    backgroundColor: colors.backgroundAlt,
    paddingVertical: 12,
    paddingHorizontal: 20,
    borderRadius: 8,
    borderWidth: 2,
    borderColor: colors.border,
  },
  deleteModalCancelText: {
    fontSize: 14,
    fontWeight: '600',
    color: colors.text,
    textAlign: 'center',
  },
  deleteModalConfirmButton: {
    flex: 1,
    backgroundColor: colors.error,
    paddingVertical: 12,
    paddingHorizontal: 20,
    borderRadius: 8,
  },
  deleteModalConfirmText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#FFFFFF',
    textAlign: 'center',
  },
});
